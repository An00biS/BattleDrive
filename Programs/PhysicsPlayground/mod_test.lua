--[[MOD-TEST for the Battledale framework.Created by Petr 'An00biS' Ohl√≠dalThis software is released under the terms of LPCL license v1.3 or, 	at your option, any later version.See the accompanying file LICENSE.TXT for details.For definition of "community", see COMMUNITY.TXT--]]--[[ A mod must implement these functions:called in main:update-- init-- mousemovedcalled in relevant love callbacks:-- update(elapsed)-- draw -- mousepressed -- mousereleased-- keypressed-- keyreleased-- joystickpressed-- joystickreleased --]]------------------------------- Configuration ----------------------------------config = {	-- world's gravity	gravityX = 0;	gravityY = 0;		---- Phys viewport settings ----	physCam = {		-- scale		x = 100;		y=100;		w=300;		h=300;	};	rootPath = "mod_test/";};-- tile size	config.tileW = 499;--500;config.tileH = 349;--350;-- Game map size. Physics world size is computed from this.config.mapW = config.tileW*6; config.mapH = config.tileH*6;-- Controlscontrols = {	mainCamera = { 		goDown=love.key_down, 		goUp=love.key_up, 		goLeft=love.key_left, 		goRight=love.key_right,		toggleUseCustomRenderers=love.key_c;	},	newExtraGfxCam = love.key_n;	newPhysCam = love.key_p;	openTestWindow = love.key_t;	openSpawnWindow = love.key_m;	units = {		spawnBall = love.key_b;		spawnPrism = love.key_h;		spawnTurretStand = love.key_u;		spawnBlasterTurret = love.key_t;	};		reset = love.key_r;	newMouseJoint = love.mouse_left;	hover = {		goLeft = love.key_a;		goRight = love.key_d;		goForward = love.key_w;		goBackward = love.key_s;	};	};return function( bd, bdgui ) -- Module---- Mod construction ----local Mod = {};-- Libraries-- Leiflove.filesystem.include( "leif/leif.lua" );leif.load();---- Mod includes ----require(config.rootPath.."mod_test_graphics.lua")(Mod,bd,bdx,bdgui,bdguix);-- These tables hold experimental new features of the librariesbdx = require(config.rootPath.."mod_test_bdx.lua")(bd);bdguix = require(config.rootPath.."mod_test_bdguix.lua")(bd,bdgui);-- user interfacerequire(config.rootPath.."mod_test_ui.lua")(Mod);-- AIrequire(config.rootPath.."mod_test_ai.lua")(Mod, bd, bdx);-- Unitsrequire(config.rootPath.."mod_test_units.lua")(Mod, bd, bdx, bdgui, bdguix);-- ConvertersMod.converter = bdx.newLinearConverter();Mod.mapConverter = bdx.newMapConverter();-- FontsMod.fonts = {};Mod.fonts.default12 = love.graphics.newFont(love.default_font, 12);Mod.fonts.default10 = love.graphics.newFont(love.default_font, 10);love.graphics.setFont(Mod.fonts.default12);---- Global variables -----Mod.pi4 = math.pi*4;-- Tells which phys camera the cursor is in, if any.-- It contains a reference to the camera, or false if it's not in any Mod.physViewportWithCursor = false;-- Same meaning, but references a graphical viewportMod.gfxViewportWithCursor = false;Mod.debug = {};Mod.mouseJointHolder = {}; -- table for shared access to the mouse jointMod.towerGrobs = {};Mod.shadowGrobs = {};Mod.entities = {};-- TeamsMod.teams = {	player = {		name = "Player";	};	top = {		name = "Top";	};	bottom = {		name = "Bottom";	};};Mod.teams.top.enemies = {Mod.teams.bottom};Mod.teams.bottom.enemies = {Mod.teams.top};Mod.teams.player.enemies = {};-- SettingsMod.settings = {	showHpBars = false;	spawnUnitTeam = Mod.teams.player;};Mod.controls = controls;local tileset = {};tileset[1]=love.graphics.newImage("graphics/Grass_500x350.png",love.image_pad_and_optimize);tileset[1]:setCenter(0,0);tileset[2]=love.graphics.newImage("graphics/Grass_Greener_500x350.png",love.image_pad_and_optimize);tileset[2]:setCenter(0,0);tileset[3]=love.graphics.newImage("graphics/Pavement_500x350.png",love.image_pad_and_optimize);tileset[3]:setCenter(0,0);-- MapMod.map = bd.newMap( 	config.mapW, config.mapH, -- parcel size	1,1, -- map size in parcels	tileset, -- tileset	config.tileW, config.tileH ); -- tile sizeMod.map.pixelWidth, Mod.map.pixelHeight = Mod.map:getPixelSize();bd.instant.checkerMap( Mod.map, 1, 2, 3 );--print("<init> map pixel w h ",Mod.map.pixelWidth, Mod.map.pixelHeight);-- Main camera--_map, _mapPosVec, _viewportRect,_visibleGrobs, _notVisibleGrobsMod.mainCameraViewport = bd.newRectangle( 10,10,780,580 );Mod.mainCamera = bd.newGfxCamera( 	Mod.map,	bd.newVector(Mod.map.pixelWidth/2, Mod.map.pixelHeight/2),	Mod.mainCameraViewport, Mod.grobs );Mod.mainCamera.customDrawingFunctions:add(Mod.ai.drawTargetingLines);-- Main camera mover (for controlling by keyboard)Mod.mainCameraMover = bd.newXYMover( 150,150,  166,166,  288,288, 	function(x,y) Mod.mainCamera:moveOnMap(x,y) end );---- Shape list ----Mod.shapes = {	borderPolys = {};	staticPolys = {};	staticCircles = {};	movingPolys = {};	movingCircles = {};	sensorPolys = {};	sensorCircles = {};};--[[-- Units lists ----Mod.units = {	balls = {},	prisms = {},	hovers = {},	tanks = {},	turretStands = {},	blasterTurrets = {}};--]]-- Physics worldlocal worldW,worldH = Mod.mapConverter:pixelsToB2Meters(config.mapW, config.mapH);Mod.world, Mod.ground = bd.instant.physWorld( 		worldW, worldH,		true,		Mod.shapes.borderPolys, 		config.gravityX, 		config.gravityY );-- Test shapesMod.shapes.staticPolys.tlRect =	love.physics.newPolygonShape( Mod.ground,  0,0,  10,8,  8,10 );Mod.shapes.staticPolys.brRect = love.physics.newPolygonShape( Mod.ground,	Mod.map.pixelWidth*0.02, Mod.map.pixelHeight*0.02,	Mod.map.pixelWidth*0.02-10, Mod.map.pixelHeight*0.02-8,	Mod.map.pixelWidth*0.02-8,Mod.map.pixelHeight*0.02-10 );Mod.shapes.staticPolys.testRect =  love.physics.newRectangleShape( Mod.ground, 	Mod.converter:pixelsToB2Meters(100,100,20,30) );-- GUIMod.desk = bdgui.draw.desk( bdgui.newDesk() );----- Camera windows --------- Phys camerasMod.physCamWindows = {};function Mod:removePhysCamWindow( indexOrPointer ) 	print("<Mod:removePhysCamWindow> arg:"..tostring(indexOrPointer));	if( type(indexOrPointer)=="table" ) then		bd.table.removeByValue(self.physCamWindows, indexOrPointer);		--[[for index, viewport in ipairs(self.physCamWindows) do			if( viewport == indexOrPointer ) then				table.remove( self.physCamWindows, index );				return;			end;		end;]]	else		index = index or #self.physCamWindows;		table.remove( self.physCamWindows, index );	end;end;-- A function which draws X into a BDGUI sheet. Made for use with sheet_drawExtra function.local function drawXIntoSheet( self )	local origWidth = love.graphics.getLineWidth();		love.graphics.setColor( 255,0,0,255 );	love.graphics.setLineWidth( 2 );	love.graphics.line( self.absolutePos.x, self.absolutePos.y, 			self.absolutePos.x+self.w, self.absolutePos.y+self.h );	love.graphics.line( self.absolutePos.x+self.w, self.absolutePos.y, 			self.absolutePos.x, self.absolutePos.y+self.h );		love.graphics.setLineWidth(origWidth);end;function Mod:addPhysCamWindow( _x, _y, _w, _h )	local window = bdguix.openEquippedWindow( self.desk, _x, _y, _w, _h ); 	local closePhysCamWinFunction = function(self) 		Mod:removePhysCamWindow(window);		bdguix.closeWindow(window);	end;	window.buttons.close.onMouseUp:add(closePhysCamWinFunction);	local viewport 		= window:newSheet( 15, 15, _w-30, _h-30, bdgui.arrange.fixedPosLinkedScale );	--viewport.parentChanged = sheet_parentChangedLinkedScale;	local camera = bd.newPhysCamera( 5, 0.00000000001, 0.05, 0.05, {x=0,y=0}, viewport, 		Mod.shapes, Mod.converter, Mod.mouseJointHolder );	window.camera = camera;	viewport.onMouseDown:add( 		function( sheet, x,y,button ) 			--print("<viewport onmousedown>, button ",button,"wheelup",love.mouse_wheelup);			if( button == love.mouse_wheelup  ) then				--print("<viewport> zoomin");				camera:zoomIn();			elseif( button == love.mouse_wheeldown ) then				--print("<viewport> zoomout");				camera:zoomOut();			end;		end );	viewport.onDrag:add( 		function(sheet,newX,newY,oldX,oldY, buttons) 			if(buttons.right) then				camera:moveOnWorld( oldX-newX, oldY-newY );			end;		end );	viewport.onMouseOver:add( function() Mod.physViewportWithCursor = camera end );	viewport.onMouseOut:add( function() Mod.physViewportWithCursor = false end );	viewport.draw = function( self ) camera:draw() end;	table.insert( self.physCamWindows, 1, window );end;---- Extra gfx camerasMod.extraGfxCamWindows = {};function Mod:removeExtraGfxCamWindow( indexOrPointer )	--print("<mod:removeExtraGfxCamWindow> indexOrPointer:"..tostring(indexOrPointer));	if( type(indexOrPointer)=="table" ) then		bdx.table.removeByValue(self.extraGfxCamWindows,indexOrPointer);		--[[for index, viewport in ipairs(self.extraGfxCamWindows) do			if( viewport == indexOrPointer ) then				table.remove( self.extraGfxCamWindows, index );				return;			end;		end;]]	else		index = index or #self.extraGfxCamWindows;		table.remove( self.extraGfxCamWindows, index );	end;end;function Mod:addExtraGfxCamWindow( _x, _y, _w, _h )	local window = bdguix.openEquippedWindow( self.desk, _x, _y, _w, _h ); 	window.closeFunction = function(self)		Mod:removeExtraGfxCamWindow(window);		self.parent:removeSheet(self);	end;	local viewport = window:newSheet( 		15, 15, _w-30, _h-30, 		bdgui.arrange.fixedPosLinkedScale );	window.camera = bd.newGfxCamera( Mod.map, {x=0;y=0}, viewport );	viewport.draw = function() window.camera:draw() end;	viewport.onDrag:add(		function( self, newX, newY, oldX, oldY )			window.camera:moveOnMap( oldX-newX, oldY-newY )		end	);	window.camera:addGrobs(Mod.towerGrobs);	window.camera:addGrobs(Mod.towerGrobs);	table.insert( self.extraGfxCamWindows, 1, window );end;console = bd.newDebugConsole( f,14,  10,10,  780,580,  0,0 );--[[ ====================== TEST hover =========================Mod.testHover = {};local b = love.physics.newBody( Mod.world, bd.pixelsToB2Meters(500), bd.pixelsToB2Meters(300) );local function tob2( ... )	local vals = {...};	for index, value in ipairs( vals ) do		vals[index] = bd.pixelsToB2Meters(value);	end;	return unpack(vals);end;table.insert( 	Mod.shapes.movingPolys, 	love.physics.newPolygonShape( b, tob2(0,0,  42,0,  42,11,  27,18,  15,18,  0,11) ));table.insert(	Mod.shapes.movingPolys,	love.physics.newPolygonShape( b, 		tob2(15,18,  27,18,  34,46,  26,60,  15,60,  8,46) ));b:setMassFromShapes();-- == Expected attributes: ==-- maxSpin -- degrees per second-- spinUp-- spinDown -- slowdown-- acceleration-- braking-- maxSpeed-- reverseBraking-- reverseAcceleration-- reverseMaxSpeed-- body (b2Body)-- drive = {goLeft,goRight,goForward,goBackward}-- bdglobalhover = {	maxSpin = 300;	spinUp = 100;	spinDown = 50;	slowdown = 10;	acceleration = 60;	braking = 20;	maxSpeed = 300;	reverseBraking = 20;	reverseAcceleration = 40;	reverseMaxSpeed = 200;	body = b;	drive = {goLeft=false,goRight=false,goForward=false,goBackward=false};};hover.move = require 'battledale_undercart_tracked.lua'(bd);-- --============ TEST hover END ==============================]]--Mod.balls = Mod.units.balls;--Mod.prisms=Mod.units.prisms;--- Puts supplied grob into the mod's grob list, all gfx cameras and other optinal tables.function Mod:distributeTowerGrob(grob)	if (not grob) then 		return;	end;	table.insert(Mod.towerGrobs, grob);	self.mainCamera:addTowerGrob(grob);	for index, window in ipairs(Mod.extraGfxCamWindows) do		window.camera:addTowerGrob(grob);	end;end;--- Removes supplied grob from the mod's grob list, all gfx cameras and other optinal tables.function Mod:removeTowerGrob(grob)		if (not grob) then 		return;	end;	bd.table.removeByValue(Mod.towerGrobs,grob);	self.mainCamera:removeTowerGrob(grob);	for index, window in ipairs(Mod.extraGfxCamWindows) do		window.camera:removeTowerGrob(grob);	end;end;--- Puts supplied grob into the mod's grob list, all gfx cameras and other optinal tables.function Mod:distributeShadowGrob(grob)	if (not grob) then 		return;	end;	table.insert(Mod.shadowGrobs, grob);	Mod.mainCamera:addShadowGrob(grob);		for index, window in ipairs(Mod.extraGfxCamWindows) do		window.camera:addShadowGrob(grob);	end;end;--- Removes supplied grob from the mod's grob list, all gfx cameras and other optinal tables.function Mod:eraseShadowGrob(grob)	if (not grob) then 		return;	end;	self.mainCamera:removeShadow(grob);	bd.table.removeByValue(Mod.shadowGrobs, grob);	for index, window in ipairs(Mod.extraGfxCamWindows) do		window.camera:removeShadow(grob);	end;end;--- Introduces a new entity into the game.--  Adds it into mod's entity list, distributes it's grobs and physical shapes.function Mod:addEntity(e)	if(e.getTowerGrob)then		self:distributeTowerGrob(e:getTowerGrob());	end;	if(e.getShadowGrob)then		self:distributeShadowGrob(e:getShadowGrob());	end;	if(e.getMovingCircles)then		table.insert(self.shapes.movingCircles,e:getMovingCircles());	end;	if(e.getMovingPolys)then		table.insert(self.shapes.movingPolys,e:getMovingPolys());	end;	if(e.getStaticCircles)then		table.insert(self.shapes.staticCircles,e:getStaticCircles());	end;	table.insert(self.entities, e);end;--- Removes an entity from the game--  Erases it's grobs from all cameras and erases it's phys. shapes from shape lists.function Mod:removeEntity(e)	self:eraseTowerGrob(e:getTowerGrob());	if(e.getShadowGrob)then		self:eraseShadowGrob(e:getShadowGrob());	end;	if(e.getMovingCircles)then		bd.table.removeByValue(self.shapes.movingCircles,e:getMovingCircles());	end;	if(e.getMovingPolys)then		bd.table.removeByValue(self.shapes.movingPolys,e:getMovingPolys());	end;	if(e.getStaticCircles)then		bd.table.removeByValue(self.shapes.staticCircles,e:getStaticCircles());	end;	bd.table.removeByValue(self.entities, e);end;--- Introduces a new combat unit (specialized entity) in the gamefunction Mod:addUnit(u)	self:addEntity(u);	table.insert(self.units,u);end;--- Removes a combat unit (specialized entity) from the gamefunction Mod:removeUnit(u)	self:removeEntity(u);	bd.table.removeByValue(self.units,u);end;---- Event callbacks ----function Mod:keypressed( key )	leif.keyPressed(key);	-- Main camera movement and properties	    if( Mod.controls.mainCamera.goUp == key ) then Mod.mainCameraMover.goUp=true; return;	elseif( Mod.controls.mainCamera.goDown == key ) then Mod.mainCameraMover.goDown=true; return;	elseif( Mod.controls.mainCamera.goLeft == key ) then Mod.mainCameraMover.goLeft=true; return;	elseif( Mod.controls.mainCamera.goRight == key ) then Mod.mainCameraMover.goRight=true; return;	elseif( Mod.controls.mainCamera.toggleUseCustomRenderers==key ) then 		Mod.mainCamera:setUseCustomRenderers(not Mod.mainCamera:getUseCustomRenderers()); return;	elseif( Mod.controls.openSpawnWindow == key and Mod.ui.spawnPanel==nil ) then		Mod.ui.openSpawnPanel(); return;	-- Opening new cameras		elseif( Mod.controls.newExtraGfxCam == key ) then 		self:addExtraGfxCamWindow(100,100,400,300); return;	elseif( Mod.controls.newPhysCam == key ) then 		self:addPhysCamWindow(			config.physCam.x,			config.physCam.y,			config.physCam.w,			config.physCam.h);		return;	--elseif( Mod.controls. == key ) then  return;		elseif( Mod.controls.reset == key ) then love.system.restart(); return;	-- elseif( Mod.controls. == key ) then self:(); return;		-- Hover	elseif( Mod.controls.hover.goLeft == key ) then hover.drive.goLeft=true; return;	elseif( Mod.controls.hover.goRight == key ) then hover.drive.goRight=true; return;	elseif( Mod.controls.hover.goForward == key ) then hover.drive.goForward=true; return;	elseif( Mod.controls.hover.goBackward == key ) then hover.drive.goBackward=true; return;	end;		---- Spawning ----	local mouseMapX, mouseMapY = 0,0;	if( self.physViewportWithCursor) then 		local mouseWorldX, mouseWorldY = self.physViewportWithCursor:computeWorldPos(					love.mouse.getX(), love.mouse.getY());		mouseMapX, mouseMapY = 			Mod.mapConverter:b2MetersToPixels(mouseWorldX, mouseWorldY);	else		mouseMapX, mouseMapY 			= Mod.mainCamera:computeMapPos(love.mouse.getX(),love.mouse.getY());	end;		if(key == self.controls.units.spawnBall ) then		--print("====spawn ball====\nmouseMapX",mouseMapX,"mouseMapY",mouseMapY);		self:addEntity( self.units.spawnBall( 			mouseMapX, mouseMapY, 0, Mod.settings.spawnUnitTeam ));	elseif(key==self.controls.units.spawnPrism) then		self:addUnit( self.units.spawnPrism( 			mouseMapX, mouseMapY, 0, Mod.settings.spawnUnitTeam ));	elseif(key==self.controls.units.spawnTurretStand) then		self:addEntity( self.units.spawnTurretStand( 			mouseMapX, mouseMapY, 0, Mod.settings.spawnUnitTeam ));	elseif(key==self.controls.units.spawnBlasterTurret)then		--print("spawn blaster turret");		self:addUnit( self.units.spawnBlasterTurret(			mouseMapX, mouseMapY, 0, Mod.settings.spawnUnitTeam) );		end;	end;function Mod:keyreleased(key) 	leif.keyReleased(key);	-- Main camera movement	    if key == game.controls.mainCamera.goUp then self.mainCameraMover.goUp = false; return; 	elseif key == game.controls.mainCamera.goDown then self.mainCameraMover.goDown = false; return; 	elseif key == game.controls.mainCamera.goLeft then self.mainCameraMover.goLeft = false; return; 	elseif key == game.controls.mainCamera.goRight then self.mainCameraMover.goRight = false; return; 		-- Hover	elseif( Mod.controls.hover.goLeft == key ) then hover.drive.goLeft=false; return;	elseif( Mod.controls.hover.goRight == key ) then hover.drive.goRight=false; return;	elseif( Mod.controls.hover.goForward == key ) then hover.drive.goForward=false; return;	elseif( Mod.controls.hover.goBackward == key ) then hover.drive.goBackward=false; return;		end;end;function Mod:mousemoved( newX, newY, oldX, oldY )		self.desk:mousemoved( newX, newY, oldX, oldY );		-- If there's mouse joint, update it	if( self.physViewportWithCursor and self.mouseJointHolder.joint )then		self.mouseJointHolder.joint:setTarget(				self.physViewportWithCursor:computeWorldPos(newX,newY));	end;end;function Mod:mousepressed( x,y,button ) 	leif.mousePressed(x,y,button);	self.desk:mousepressed( x,y,button );	if(self.physViewportWithCursor and button==self.controls.newMouseJoint )then		local worldX,worldY = self.physViewportWithCursor:computeWorldPos(x,y);		local body = self.physViewportWithCursor:getBodiesOnPoint(worldX,worldY);		if(body)then			self.mouseJointHolder.joint = love.physics.newMouseJoint( body,worldX,worldY );		end;	end;end;function Mod:mousereleased( x,y,button )	leif.mouseReleased(x,y,button);	self.desk:mousereleased( x,y,button );	-- If there's mouse joint, delete it	if( self.mouseJointHolder.joint )then		self.mouseJointHolder.joint:destroy();		self.mouseJointHolder.joint=nil;	end;end;function Mod:update( elapsed )	leif.update( elapsed )	console:printLn("FPS:"..love.timer.getFPS());	self.world:update(elapsed);	self.desk:update( elapsed );		-- Move camera	self.mainCameraMover:move( elapsed );		-- Update entities	for index, e in ipairs(self.entities) do		if e.update then			e:update(elapsed);		end;				if(e.dead)then			self:removeEntity(e);		end;		--console:printLn("<grob> z:",grob.z);		--console:printLn("<grob> angle:",grob.angle);	end;		--hover:move(elapsed);	--[[	console:printLn(		"Speed:"..hover.body:getVelocityLocalPoint(0,0)		.." spin:"..hover.body:getSpin());	for index, prism in ipairs(Mod.prisms) do		console:printLn("<main> prism"..index.." angle:"..prism.body:getAngle());	end;	--]]	console:printLn("Main camera grobs:"		..self.mainCamera:getNoVisibleTowerGrobs()+self.mainCamera:getNoVisibleShadowGrobs()		.."/"..self.mainCamera:getNoTowerGrobs()+self.mainCamera:getNoShadowGrobs());		if(self.physViewportWithCursor)then		Mod.debug.mousePointedBody = 			self.physViewportWithCursor:getBodiesOnPoint(				self.physViewportWithCursor:computeWorldPos(love.mouse.getX(),love.mouse.getY()));	end;	--[ [ Cursor body lookup test	-- This displays which physics body is currently pointed with mouse	console:printLn("Pointed body:",Mod.debug.mousePointedBody);	--]]		--[ [ Mouse joint	if(self.mouseJointHolder.joint)then		local x1,y1,x2,y2 = self.mouseJointHolder.joint:getAnchors();		console:printLn("Mouse joint: from",x1,y1,"to",x2,y2);	end;	--]]		--[ [ Test function PhysCamera:computeWorldPos(screenX, screenY)	if(self.physViewportWithCursor)then		console:printLn(			self.physViewportWithCursor:computeWorldPos(love.mouse.getX(),love.mouse.getY()));	end;		--]]		--[ [ DEBUG	console:printLn("New units team:"..Mod.settings.spawnUnitTeam.name);	--]]end;function Mod:draw()	self.mainCamera:draw();	self.desk:draw();	local color = love.graphics.getColor();	leif.draw( );	love.graphics.setColor(color);	console:draw();	end;return Mod;end;